server {
    listen 80;
    server_name *.localhost;

    set_by_lua_block $subdomain {
        if ngx.var.host:match("^(.*)%.localhost$") then
        return ngx.var.host:match("^(.*)%.localhost$")
        end
        return ""
    }

    set $prefix '';
    set $home '';
    set $store_id '';

    access_by_lua_block {
        local prefix_lookup = require("subdomain_prefix_lookup")
        local prefix, home, banned, store_id = prefix_lookup(ngx.var.subdomain)

        ngx.log(ngx.INFO, "store_id, " .. ngx.var.store_id)

        if banned then
        ngx.log(ngx.INFO, "User is banned, setting is_banned to 1")
        ngx.var.prefix = "custom"
        ngx.var.home = "403.html"
        return
        end

        if not prefix then
        ngx.log(ngx.ERR, "No prefix found for subdomain: " .. ngx.var.subdomain)
        return ngx.exit(ngx.HTTP_NOT_FOUND)
        end

        ngx.var.prefix = prefix
        ngx.var.store_id = store_id

        if home then
        ngx.var.home = home
        else
        ngx.var.home = "" -- Set empty string if home is nil
        end

    }

    proxy_intercept_errors on;


    location = / {
        proxy_pass http://minio:9000/billingsystem/$prefix/$home;
        proxy_cache off;
        # proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_buffering off; # Disable buffering for better streaming

        add_header X-Forwarded-store-id $store_id;
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate";
        add_header Pragma "no-cache";
        add_header Expires "0";
    }


    location / {
        proxy_pass http://minio:9000/billingsystem/$prefix$request_uri;
        # proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $host;

        proxy_buffering off;
        proxy_cache off;

        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate";
        add_header Pragma "no-cache";
        add_header Expires "0";
    }
    location /cdn/js/dsb-order.js {
        # Serve the original JS file from MinIO/S3
        proxy_pass http://minio:9000/cdn/js/dsb-order.js;

        # Extract store_id from query parameter (adjust as needed)
        # set $store_id $arg_store_id;
        # Alternative sources if not in query params:
        # set $store_id $cookie_store_id;  # From cookie
        # set $store_id $http_x_store_id;  # From header

        # Headers to prevent caching
        proxy_set_header Cache-Control "no-cache, no-store, must-revalidate";
        proxy_set_header Pragma "no-cache";
        proxy_set_header Expires "0";
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Required for sub_filter to work
        proxy_set_header Accept-Encoding "";

        # Inject the storeId variable
        sub_filter 'storeId: null' 'storeId: "$store_id"';
        sub_filter_once off;  # Replace all occurrences
        sub_filter_types application/javascript;

        # Add store ID to response header for debugging
        add_header X-Store-ID $store_id;
    }

    error_page 404 500 502 503 403 504 /404.html;

    location = /404.html {
        proxy_pass http://minio:9000/billingsystem/custom/404.html;
    }
}
